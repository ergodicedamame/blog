---
title: 'Working in Julia: Environments, packages, and all that jazz'
subtitle: Comparing working in Julia with working in Python using mamba.
date: 2022/07/17
image: logo.png
categories:
  - how-to
  - julia
jupyter:
  jupytext:
    formats: 'ipynb,qmd'
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: '1.0'
      jupytext_version: 1.13.1
  kernelspec:
    display_name: Julia 1.7.3
    language: julia
    name: julia-1.7
---

```{julia}
#| echo: false

# NOTE This works when using quarto render, which deals with pwd.
# It does not work if you run the notebook locally and spin up 
# the IJulia kernel from a different path. Usual kernels issue. 
for f in ["Project.toml", "Manifest.toml"]
  if f in readdir()
    rm(f)
  end
end
```

This is a quick note on how to get up and running in Julia, comparing it to working in Python with mamba[^1] and IPython. 
The focus is on setting up a "work station" for light-weight modelling in Julia.
We will not consider package development, etc.

[^1]: "Mamba is a _[faster and all around better]_ reimplementation of the conda package manager" - [mamba repo](https://github.com/mamba-org/mamba).

## Installing Julia

The official, but not yet released, [juliaup](https://github.com/JuliaLang/juliaup) is the suggested way to install Julia, and manage multiple versions.
There seems to also be a conda-forge [feedstock](https://github.com/conda-forge/juliaup-feedstock), so one can run

```mamba install juliaup```

instead of 

````curl -fsSL https://install.julialang.org | sh````

The juliaup commands are currently documented in the GitHub [README](https://github.com/JuliaLang/juliaup#using-juliaup).
The most important are

```juliaup add X.Y.Z```

to install a given version of julia, and

```julia +X.Y.Z```

to run it.

__NOTE:__ This is the first big difference with mamba, which manages (versions of) Python along with the packages in a given environment. 
This seems to be an oversight when it comes to reproducibility in Julia, unless there are future plans to somehow pin Julia in the Manifest.toml (see below) and/or integrate it with juliaup.

## Environments and packages

Once in the Julia REPL, `[` switches you to the Pkg REPL.
With the `st` (or `status`) and `?` commands, you are then good to go.

### Managing environments

Environments are core to Julia via Pkg.
This is however compared with virtualenv rather than mamba in the Pkg [docs](https://pkgdocs.julialang.org/v1/), and indeed has a number of differences to mamba.

`activate .` in the Pkg REPL, or `Pkg.activate(".")` in the Julia REPL, will either switch to the environment in the current folder[^2], or create new a new environment, and toml files, if this does not already exist.

[^2]: This is to be taken with a pinch of salt in Jupyter, where kernels are not necessarily initialised relative to the path of the notebook.

`activate`, with no argument, returns to the default environment.

Let's now see this in action...

Listing the files in the current folder, we get the following.

```{julia}
readdir()
```

We now activate an environment in the current location.

```{julia}
#| output: false
import Pkg
Pkg.activate(".")
```

And then install a package.

```{julia}
Pkg.add("Example")
```

Listing the files again, we see a new Porject.toml and Manifest.toml.

```{julia}
readdir()
```

We can also inspect their contents.

```{julia}
print(read("Project.toml", String))
```

```{julia}
print(read("Manifest.toml", String))
```

Project.toml is like a hand crafted mamba environment.yaml file, whereas Manifest.toml is like an exported (and thus frozen) mamba environment file.

```{julia}
# TODO what is the differnece between activate and instantiate?
Pkg.instantiate()
```

### Managing packages

From above, we see that unlike in mamba, we need package UUIDs[^3], so it is easier to manage packages via the Pkg REPL than manually tweaking the Project.toml.
While this is a bit annoying, we can do `add A B C` to install multiple packages at once. Cf. 

```mamba install -c conda-forge A B C```

[^3]: This is necessary because Julia supports federated package management and there is no central naming authority, so multiple packages can have the same name. See [docs](https://docs.julialang.org/en/v1/manual/code-loading/#Federation-of-packages).

We can also use `add Example@0.4` to pin versions, and `add Example#master` for branches. 
As well as installing unregistered packages, e.g. 

```add https://github.com/fredrikekre/ImportMacros.jl```

`st [--manifest]` allows us to see what packages are contained in the environment.

`rm Example`, and variants for Manifest, allow us to remove packages. See [here](https://pkgdocs.julialang.org/v1/managing-packages/#Removing-packages).

Package management in Julia is tightly coupled with GitHub, but now there is also a Julia package server, used by default, see [here](https://pkgdocs.julialang.org/v1/managing-packages/#Pkg-client/server).

### Using environments

TODO 

- read https://docs.julialang.org/en/v1/manual/code-loading/#Environments and talk about how julia selects "closes" env by default.


## Importing functions and packages

TODO 

- `using Example` - precompiles pkg and dependencies. import doesn't?
- `import Example`
- read https://docs.julialang.org/en/v1/manual/code-loading/

## Julia kernels

TODO

- IJulia kernels


## Using Python packages

TODO

- figure out how to choose conda environment being used
- note that julia can install python via conda - not mamba. figure out.
- what about R?


## Other features in Julia Pkg

TODO

- testing is also done via Pkg.


## Other, related, useful packages and features in Julia

TODO

- [Revise.jl](https://timholy.github.io/Revise.jl/stable/) may be similar to autoreload?!
