[
  {
    "objectID": "posts/heatmaps-clustering/index.html",
    "href": "posts/heatmaps-clustering/index.html",
    "title": "Heatmaps done right",
    "section": "",
    "text": "Given a distance matrix, i.e. a symmetric matrix of distances between observations, if the indices of the observations are arbitrary, or more generally there is no variable by which we want to order the observations, then plotting it as a heatmap using the default ordering (of the indices) is often not very useful. If we do so, we get a heatmap where the rows and columns are ordered abritrarily and the plot itself may be hard to interpret. In many cases, a better approach is to cluster the observations and use the new ordering This will lead to a heatmap in which similar observations are grouped. This is what sns.clustermap offers, as seen in the docs.\nNote that the data itself is not the focus here. We just need a distance matrix in order to show how it can be reordered. We will use the USA presidential speeches, and consider distances between texts, to walk through the clustering and then do the plotting using altair for interactivity - as much as we like seaborn (and it’s next generation API looks very cool), interactivity is great! Then again from the source code, it looks like a lot of thought has been put into clustermap, so there might be other reasons to use it."
  },
  {
    "objectID": "posts/heatmaps-clustering/index.html#set-up",
    "href": "posts/heatmaps-clustering/index.html#set-up",
    "title": "Heatmaps done right",
    "section": "Set up",
    "text": "Set up\n\n!pip install -r requirements.txt"
  },
  {
    "objectID": "posts/heatmaps-clustering/index.html#imports",
    "href": "posts/heatmaps-clustering/index.html#imports",
    "title": "Heatmaps done right",
    "section": "Imports",
    "text": "Imports\n\nimport altair as alt\nimport nltk\nfrom nltk.corpus import inaugural\nimport pandas as pd\n\n# from scipy.spatial.distance import pdist\nfrom scipy.cluster import hierarchy"
  },
  {
    "objectID": "posts/heatmaps-clustering/index.html#data",
    "href": "posts/heatmaps-clustering/index.html#data",
    "title": "Heatmaps done right",
    "section": "Data",
    "text": "Data\nLet us quickly get the presidential addresses from nltk, and then compute the Jaccard distance on the 5-shingles1.1 Shingles are substrings of a certain length that are created by passing a moving window along the text. This choice of representation of the texts is common when working with web data, and can deal with mispellings and the sequential nature of text (to some extent). See e.g. (Schütze, Manning, and Raghavan 2008, sec. 19.6).\nFirst we download and import the data.\n\nnltk.download(\"inaugural\")\n\n\nids = inaugural.fileids()\ndata = [\n    {\n        \"id\": i,\n        \"year\": id.split(\"-\")[0],\n        \"president\": (id.split(\"-\")[1]).split(\".\")[0],\n        \"text\": inaugural.raw(fileids=id).lower(),\n    }\n    for i, id in enumerate(ids)\n]\ndf = pd.DataFrame(data)\n\nThen we shingle the text.\n\ndef get_shingles(x, size=5):\n    x = x + (size * \" \")\n    shingles = [x[i : i + size] for i in range(0, len(x) - size)]\n    return shingles\n\n\ndf[\"shingles\"] = df[\"text\"].apply(get_shingles)\n\nAnd finally we can compute the Jaccard similarity.\n\ndef get_similarity(x, y, precision=3):\n    a = set(x)\n    b = set(y)\n    return round(len(a.intersection(b)) / len(a.union(b)), precision)\n\n\ndf_pairs = df.copy()\ndf_pairs[\"key\"] = 0\ndf_pairs = df_pairs.merge(df_pairs, on=\"key\").drop(columns=[\"key\"])\n\ndf_pairs[\"similarity\"] = df_pairs.apply(\n    lambda row: get_similarity(row[\"shingles_x\"], row[\"shingles_y\"]), axis=1\n)\n\ndf_pairs.drop(columns=[\"text_x\", \"text_y\", \"shingles_x\", \"shingles_y\"], inplace=True)\n\n\ndf_pairs.head()\n\n\n\n\n\n  \n    \n      \n      id_x\n      year_x\n      president_x\n      id_y\n      year_y\n      president_y\n      similarity\n    \n  \n  \n    \n      0\n      0\n      1789\n      Washington\n      0\n      1789\n      Washington\n      1.000\n    \n    \n      1\n      0\n      1789\n      Washington\n      1\n      1793\n      Washington\n      0.071\n    \n    \n      2\n      0\n      1789\n      Washington\n      2\n      1797\n      Adams\n      0.231\n    \n    \n      3\n      0\n      1789\n      Washington\n      3\n      1801\n      Jefferson\n      0.219\n    \n    \n      4\n      0\n      1789\n      Washington\n      4\n      1805\n      Jefferson\n      0.218"
  },
  {
    "objectID": "posts/heatmaps-clustering/index.html#clustering",
    "href": "posts/heatmaps-clustering/index.html#clustering",
    "title": "Heatmaps done right",
    "section": "Clustering",
    "text": "Clustering\nClustering is straightforward. We are after the “optimal” ordering, i.e. the re-ordering with similar values placed close to each other.\n\nmat_pairs = df_pairs.pivot(index=\"id_x\", columns=\"id_y\", values=\"similarity\").to_numpy()\n\nZ = hierarchy.linkage(mat_pairs, optimal_ordering=True)\n\nreordering = hierarchy.leaves_list(Z)"
  },
  {
    "objectID": "posts/heatmaps-clustering/index.html#plotting",
    "href": "posts/heatmaps-clustering/index.html#plotting",
    "title": "Heatmaps done right",
    "section": "Plotting",
    "text": "Plotting\n\nBy date\nNote that our indices are actually ordered by date. This might be an interesting dimension and plotting the distances by date might reveal some insight from the data.\n\nw = 500\n\n\n(\n    alt.Chart(df_pairs)\n    .mark_rect()\n    .encode(\n        x=\"id_x:O\",\n        y=\"id_y:O\",\n        color=alt.Color(\"similarity:Q\", scale=alt.Scale(scheme=\"reds\")),\n        tooltip=[\"president_x\", \"year_x\", \"president_y\", \"year_y\", \"similarity\"],\n    )\n    .properties(width=w, height=w)\n    .interactive()\n)\n\n\n\n\n\nFigure 1: Heatmap using default order.\n\n\n\nIndeed, it seems like there are some interesting groups of two or three consecutive terms/presidents with similar inaugural speeches. One could probably have fun checking political party and second terms in office.\nOften however, indices are randomly assigned, in which case there is never a good reason to order by the original indices when plotting.\n\n\nBy distance\n\n(\n    alt.Chart(df_pairs)\n    .mark_rect()\n    .encode(\n        x=alt.X(\"id_x:O\", sort=alt.Sort(reordering)),\n        y=alt.Y(\"id_y:O\", sort=alt.Sort(reordering)),\n        color=alt.Color(\"similarity:Q\", scale=alt.Scale(scheme=\"reds\")),\n        tooltip=[\"president_x\", \"year_x\", \"president_y\", \"year_y\", \"similarity\"],\n    )\n    .properties(width=w, height=w)\n    .interactive()\n)\n\n\n\n\n\nFigure 2: Heatmap using re-ordering from clustering.\n\n\n\nUnfortunately, with our arbitrary choice of data, the reordering doesn’t seem to add much. However, we can still see a single main cluster of similar values that might deserve further inspection and reveal something, as well as at least one other smaller and less homogeneous cluster."
  },
  {
    "objectID": "posts/how-to/index.html",
    "href": "posts/how-to/index.html",
    "title": "Setting up a blog using quarto",
    "section": "",
    "text": "This is a minimal, living document to remind ourselves how we set up the blog, and how to write on it. We will update it as needed. It may turn out to be useful more generally, but the best place to look is the quarto site."
  },
  {
    "objectID": "posts/how-to/index.html#folders-and-files",
    "href": "posts/how-to/index.html#folders-and-files",
    "title": "Setting up a blog using quarto",
    "section": "Folders and files",
    "text": "Folders and files\nThere are a number of files needed for a quarto blog project, as we can see by taking a look at the repository. The main ones are listed here.\nOther files in the repository are needed for quarto to execute the python notebooks, github pages, etc."
  },
  {
    "objectID": "posts/how-to/index.html#github-pages-ci",
    "href": "posts/how-to/index.html#github-pages-ci",
    "title": "Setting up a blog using quarto",
    "section": "Github pages CI",
    "text": "Github pages CI\nThe website is re-built (on pushes) and deployed (on merge into main) using github actions, see workflow."
  },
  {
    "objectID": "posts/how-to/index.html#commenting-functionality",
    "href": "posts/how-to/index.html#commenting-functionality",
    "title": "Setting up a blog using quarto",
    "section": "Commenting functionality",
    "text": "Commenting functionality\nProvided by giscus, which links to github Discussions, see quarto docs and links."
  },
  {
    "objectID": "posts/how-to/index.html#writing-posts",
    "href": "posts/how-to/index.html#writing-posts",
    "title": "Setting up a blog using quarto",
    "section": "Writing posts",
    "text": "Writing posts\n\nAll posts should be stored as .qmd files, indeed .Rmd and .ipynb are included in the .gitignore.\njupytext allows to link .ipnb and .qmd notebooks, one simply needs to configure it, or use jupytext --to ipynb index.qmd for individual posts.\nevery post should have its own folder in the posts/ folder, as outlined in quarto docs.\nquarto allows to render the blog locally as one works on a new post (or any other changes) using quarto preview. This is live-reloaded whenever we save.\n\nNOTE: Any rendered content, in the docs/ folder, should not be pushed to the repository, but we cannot (simply) add it to the .gitignore, as this would break the CI which pushes the contents of docs/ to the pages branch."
  },
  {
    "objectID": "posts/discriminative-vs-generative/index.html",
    "href": "posts/discriminative-vs-generative/index.html",
    "title": "Generative vs. discriminative models",
    "section": "",
    "text": "Generative and discriminative models are known to have complementary strenghts. Following Minka (2005) and Lasserre, Bishop, and Minka (2006), we will show how they can be seen to be at different ends of a spectrum, and then discuss some of their differences in detail."
  },
  {
    "objectID": "posts/discriminative-vs-generative/index.html#generative-models-can-be-used-to-generate-synthetic-data",
    "href": "posts/discriminative-vs-generative/index.html#generative-models-can-be-used-to-generate-synthetic-data",
    "title": "Generative vs. discriminative models",
    "section": "Generative models can be used to generate synthetic data",
    "text": "Generative models can be used to generate synthetic data\nA discriminative model is one that provides \\(P \\left( y \\vert x \\right)\\) directly. The name comes from the fact that we can view the distribution (together with the decision to choose the most probable value) as directly discriminating the value of the target \\(y\\) for any given instance \\(x\\).\n\n\n\n\n\nDiscriminative model, as used for prediction.\n\n\n\n\nMirorring the definition of a discriminative model, a generative model is instead often defined as one that provides the joint probability \\(P \\left( x, y \\right)\\) in the form \\(P \\left( x \\vert y \\right)P \\left( y \\right)\\), on which one can then use Bayes’ theorem to obtain \\(P \\left( y \\vert x \\right) \\propto P \\left( x \\vert y \\right)P \\left( y \\right).\\) The graph representation for such a model is shown below.\n\n\n\n\n\nGenerative model with “default” factorization, as used for prediction.\n\n\n\n\nA good reference on classification, which introduces and compares these approaches, is Bishop (2006, chap. 4).\nThe more general definition is that a generative model is one that can generate data via ancestral sampling, i.e. sampling from the priors and passing the sampled values through the graphical model. This includes the definition above, which also has a choice of factorisation. We can also turn our discriminative model into a generative one by adding a factor for \\(P \\left( x \\right)\\), such that it too models the joint distribution \\(P \\left( x, y \\right)\\). Put differently, the factorization used in the definition of the generative model above is not what makes it a generative model. It is rather the fact that it models the joint distribution. In order to distinguish between the (first) generative model and the extended discriminative model, which is also a generative model, Mitchell refers to the former as a Bayes classifier given that it uses Bayes theorem to recover \\(P \\left( y \\vert x \\right)\\) (Mitchell 2020).\n\n\n\n\n\nExtended discriminative model with prior for \\(x\\), as used for prediction.\n\n\n\n\nNote that we sometimes also find people stating that generative models are ones that capture the causal process by which the actual data (\\(D\\)) is generated. While it is true that one might build a generative model by thinking about the causal process, it could be that the causal data generation process requires \\(P \\left( y \\vert x \\right)\\) rather than \\(P \\left( x \\vert y \\right)\\). We therefore distinguish between generative models and generative processes."
  },
  {
    "objectID": "posts/discriminative-vs-generative/index.html#generative-models-consider-a-more-restictive-parameter-space",
    "href": "posts/discriminative-vs-generative/index.html#generative-models-consider-a-more-restictive-parameter-space",
    "title": "Generative vs. discriminative models",
    "section": "Generative models consider a more restictive parameter space",
    "text": "Generative models consider a more restictive parameter space\nLet’s now look at the fundamental difference between the two model types by considering them in all generality, and focusing on their parametrisation as done by Minka (2005).\nWe write the generative model, with parameters, as\n\\[\nP_1 \\left( x, y \\vert \\theta \\right) = P_{11} \\left( x \\vert y, \\theta \\right) P_{12} \\left( y \\vert \\theta \\right).\n\\]\nWe can train the model, i.e. perform inference, to obtain the posterior probability \\(P \\left( \\theta \\vert D \\right)\\) by considering the joint distribution\n\\[\n\\begin{align*}\nP_g \\left( D, \\theta \\right)    &= P_{01} \\left( \\theta \\right) P \\left( D \\vert \\theta \\right) \\\\\n                                &= P_{01} \\left( \\theta \\right) \\prod_i P_1 \\left( x_i, y_i \\vert \\theta \\right) \\\\\n                                &= P_{01} \\left( \\theta \\right) \\prod_i P_{11} \\left( x_i \\vert y_i, \\theta \\right) P_{12} \\left( y_i \\vert \\theta \\right),\n\\end{align*}\n\\]\nwhere we have used the iid assumption on the data.\n\n\n\n\n\nParametrised generative model with training data plate.\n\n\n\n\nAlternatively, we can use maximum likelihood estimation to find \\(\\hat \\theta\\). The BIASlab couse nicely explains the different approaches with examples (de Vries, Kouw, and Koudahl 2021).\nLet’s now write the discriminative model, with parameters, as \\(P_{21} \\left( y \\vert x, \\theta \\right)\\). In order to compare it with the generative model, we extend the discriminative model by adding a probability over \\(x\\) and a second parameter in order to obtain the joint distribution\n\\[\nP_2 \\left( x, y \\vert \\theta, \\phi \\right) = P_{21} \\left( y \\vert x, \\theta \\right) P_{22} \\left( x \\vert \\phi \\right),\n\\]\nbut consider the same joint distribution by setting\n\\[\nP_{21} \\left( y \\vert x, \\theta \\right) = \\frac{P_1 \\left( x, y \\vert \\theta \\right)}{\\sum_y P_1 \\left( x, y \\vert \\theta \\right)}\n\\]\nand\n\\[\nP_{22} \\left( x \\vert \\phi \\right) = \\sum_y P_1 \\left( x, y \\vert \\phi \\right).\n\\]\nThe parameters \\(\\theta\\) and \\(\\phi\\) are of the same type, but (for now) assumed independent. We can again obtain the posterior distributions for the parameters by considering the joint distribution\n\\[\n\\begin{align*}\nP_d \\left( D, \\theta, \\phi \\right)    &= P_{01} \\left( \\theta \\right) P_{02} \\left( \\phi \\right) P \\left( D \\vert \\theta, \\phi \\right) \\\\\n                                &= P_{01} \\left( \\theta \\right) P_{02} \\left( \\phi \\right) \\prod_i P_2 \\left( x_i, y_i \\vert \\theta, \\phi \\right) \\\\\n                                &= P_{01} \\left( \\theta \\right) P_{02} \\left( \\phi \\right) \\prod_i P_{21} \\left( y_i \\vert x_i, \\theta \\right) P_{22} \\left( x_i \\vert \\phi \\right) \\\\\n                                &= \\left( P_{01} \\left( \\theta \\right) \\prod_i P_{21} \\left( y_i \\vert x_i, \\theta \\right) \\right) \\left(P_{02} \\left( \\phi \\right) \\prod_i P_{22} \\left( x_i \\vert \\phi \\right) \\right),\n\\end{align*}\n\\]\nand inferring \\(P \\left( \\theta, \\phi \\vert D \\right)\\).\n\n\n\n\n\nParametrised, extended discriminative model with training data plate.\n\n\n\n\nWe note that, due to the independence assumption, estimation of \\(\\theta\\) and \\(\\phi\\) decouples, namely if we use the factorization above to define\n\\[\nP_d \\left( D, \\theta, \\phi \\right) =: P^1 \\left( y, \\theta \\vert x \\right) P^2 \\left( x, \\phi \\right),\n\\]\nthen we see that Bayes’ rule simplifies, that is\n\\[\n\\begin{align*}\nP \\left( \\theta, \\phi \\vert D \\right)   &= \\frac{P_d \\left( D, \\theta, \\phi \\right)}{\\sum_{\\theta, \\phi} P_d \\left( D, \\theta, \\phi \\right)} \\\\\n                                        &= \\frac{P^1 \\left( y, \\theta \\vert x \\right) P^2 \\left( x, \\phi \\right)}{\\sum_{\\theta , \\phi} P^1 \\left( y, \\theta \\vert x \\right) P^2 \\left( x, \\phi \\right)} \\\\\n                                        &= \\frac{P^1 \\left( y, \\theta \\vert x \\right)}{\\sum_\\theta P^1 \\left( y, \\theta \\vert x \\right) } \\frac{P^2 \\left( x, \\phi \\right)}{\\sum_\\phi P^2 \\left( x, \\phi \\right)} \\\\\n                                        &=: P \\left( \\theta \\vert D \\right) P \\left( \\phi \\vert x \\right).\n\\end{align*}\n\\]\n\n\n\n\n\n\nComparison of parameter space considered by models. The generative model only considers the hyperplane \\(\\theta = \\phi.\\)\n\n\n\nThus \\(\\hat \\theta\\) (or equivalently \\(P \\left( \\theta \\vert D \\right)\\)) is unaffected by the estimation of \\(\\hat \\phi\\) and is the same as what we would have obtained by performing inference on the original, non-extended discriminative model.\nWe see that the fundamental difference between the two models is down to the discriminative one considering a larger parameter space without the constraint \\(\\theta = \\phi\\). This reduces the (statistical) bias, but introduces variance.\nInterestingly, there is no need to assume independence of \\(\\theta\\) and \\(\\phi\\). Considering a joint \\(P \\left( \\theta, \\phi \\right)\\) allows us to work with “hybrid” models."
  },
  {
    "objectID": "posts/discriminative-vs-generative/index.html#generative-models-require-more-assumptions",
    "href": "posts/discriminative-vs-generative/index.html#generative-models-require-more-assumptions",
    "title": "Generative vs. discriminative models",
    "section": "Generative models require more assumptions",
    "text": "Generative models require more assumptions\nWe have just shown that the generative model can be seen as considering a reduced parameter space. Furthermore, compared with the discriminative disctribution \\(P_{21} \\left( y \\vert x , \\theta \\right)\\), the joint distribution considered by the generative model is often hard to work with in practice and further simplifying assumptions are often necessary, or preferable, in order to make inference tractable.\nTo understand why generative models require more modelling assumptions, we will consider the case of Boolean inputs \\(x = \\left( x_1, \\cdots, x_n \\right)\\), \\(x_j \\in \\lbrace 0, 1 \\rbrace\\).\nIt can be instructive to update the factor graphs and draw some of the individual components of the input.\n\n\n\n\n\nDiscriminative model with two components of the input vector drawn.\n\n\n\n\n\n\n\n\n\nGenerative model with two components of the input vector drawn.\n\n\n\n\nLet us now look at the parameters necessary for the generative model by first considering the conditional probability table for \\(P\\left( x \\vert y \\right)\\) with \\(x\\) represented as a single vector.\n\n\n\n\n\\(y = 0\\)\n\\(y = 1\\)\n\n\n\\(x = (0, \\cdots, 0)\\)\n\\(\\theta^0_{1}\\)\n\\(\\theta^1_{1}\\)\n\n\n\\(x = (1, \\cdots, 0)\\)\n\\(\\theta^0_{2}\\)\n\\(\\theta^1_{2}\\)\n\n\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\n\n\\(x = (1, \\cdots, 1)\\)\n\\(\\theta^0_{2^n}\\)\n\\(\\theta^1_{2^n}\\)\n\n\n\nWe see that we have \\(2 \\times 2^n = 2^{n + 1}\\) parameters. The (conditional) probability constraints (on the columns) bring this count down to \\(2 \\left( 2^n - 1\\right)\\).\nThe other factor in the generative model, \\(P \\left( y \\right)\\), is not an issue, as we only have one effective parameter given \\(y\\) is a Boolean variable.\nFor the discriminative model, we instead have to consider \\(P \\left( y \\vert x \\right)\\). Here the conditional probability table is flipped.\n\n\n\n\n\\(x = (0, \\cdots, 0)\\)\n\\(\\cdots\\)\n\\(x = (1, \\cdots, 1)\\)\n\n\n\\(y = 0\\)\n\\(\\theta^0_{1}\\)\n\\(\\cdots\\)\n\\(\\theta^0_{2^n}\\)\n\n\n\\(y = 1\\)\n\\(\\theta^1_{1}\\)\n\\(\\cdots\\)\n\\(\\theta^1_{2^n}\\)\n\n\n\nSimply flipping the conditionality, and again using the conditional probability constraints, leads to \\(2^n\\) effective parameters. This is less parameters than those for the generative model. For large \\(n\\), essentially half as many.\nWhat is often done in generative models is to add further simplifying assumptions. In the Naive Bayes classifier for example, we assume each \\(x_i\\) is conditionally independent of all other \\(x_{-i}\\) given \\(y\\). Together with the product rule, this gives\n\\[\nP \\left(x \\vert y \\right) = \\prod_i P \\left( x_i \\vert y \\right).\n\\]\nWe can visualise this more granular factorization of the conditional probability by drawing the factor graph. This time using plate notation.\n\n\n\n\n\nGenerative model with Naive Bayes assumption.\n\n\n\n\nNow, each \\(x_i\\) has its own conditional probability table, which is simply\n\n\n\n\n\\(y = 0\\)\n\\(y = 1\\)\n\n\n\\(x_i = 0\\)\n\\(\\theta^0_{0}\\)\n\\(\\theta^1_{0}\\)\n\n\n\\(x_i = 1\\)\n\\(\\theta^0_{1}\\)\n\\(\\theta^1_{1}\\)\n\n\n\nand the conditional probability constraints bring the number of parameters per input variable from four to two. Thus, overall we have \\(2 n\\) parameters to estimate. This is now less than the \\(2^n\\) of the discriminative model (provided \\(n > 2\\)).\nOn top of the number of parameters that need to be estimated, in order to reliably estimate them, we need to observe each distinct instance multiple times. This is discussed in (Mitchell 2020).\nWe thus can, and often do, introduce futher bias in generative models in order to make them tractable. A consequence of this is that generative models can be less accurate, if they (i.e. the small world model) don’t reflect the large world model3, but (when they do) generative models require less data to train.3 This is Savage’s terminology, as presented by McElreath in Statistical Rethinking: “All statisitcal modelling has these two frames: the small world of the model itself and the large world we hope to deploy the model in.” (McElreath 2020, 19)."
  },
  {
    "objectID": "posts/discriminative-vs-generative/index.html#generative-models-can-deal-with-missing-data",
    "href": "posts/discriminative-vs-generative/index.html#generative-models-can-deal-with-missing-data",
    "title": "Generative vs. discriminative models",
    "section": "Generative models can deal with missing data",
    "text": "Generative models can deal with missing data\nLet’s turn to the often mentioned fact that generative models can deal with missing data. What this means is that they can still make predictions if given a vector of inputs \\(\\hat x = \\left( \\hat x_1, \\cdots, \\hat x_k, \\bar x_{k+1}, \\cdots, \\bar x_n \\right) = \\left( \\hat x_o, \\bar x_m \\right)\\), where \\(\\bar x_m\\) are missing, whereas discriminative models can’t.\nWhen it comes to predicting \\(\\hat y\\) given \\(\\hat x\\) (and \\(D\\)), we need the posterior predictive distribution, namely\n\\[\n\\begin{align*}\nP \\left( \\hat y \\vert \\hat x, D \\right) &= \\int_\\Theta P \\left( \\hat y, \\theta \\vert \\hat x, D \\right) \\mathrm{d} \\theta \\\\\n                                        &= \\int_\\Theta P \\left( \\hat y \\vert \\hat x, \\theta \\right) P \\left( \\theta \\vert D \\right) \\mathrm{d} \\theta,\n\\end{align*}\n\\]\nwhere we assume that the past and future observations are conditionally independent given \\(\\theta\\).\nIn the case of missing inputs, we want to consider\n\\[\n\\begin{align*}\nP \\left( \\hat y \\vert \\hat x_o, \\theta \\right)  &= \\sum_{\\bar x_m} P \\left( \\hat y, \\bar x_m \\vert \\hat x_o, \\theta \\right) \\\\\n                                                &= \\sum_{\\bar x_m} P \\left( \\hat y \\vert \\hat x_o, \\bar x_m , \\theta \\right) P \\left( \\bar x_m \\vert \\hat x_o, \\theta \\right)\n\\end{align*}\n\\]\nand plug this into the posterior predictive distribution.\n\n\n\n\n\nDiscriminative model being used for prediction, with missing inputs \\(\\bar x_m\\). Note that \\(Xo\\), \\(Xm\\) and \\(Y\\) replace \\(\\hat x_o\\), \\(\\bar x_m\\) and \\(\\hat y\\) due to graphviz limitaitons.\n\n\n\n\nIn the case of discriminative models, we have no way of evaluating the necessary probabilities because we only have \\(P_{21} \\left( y \\vert x, \\theta \\right)\\). We therefore cannot obtain \\(P \\left( \\bar x_m \\vert \\hat x_o, \\theta \\right)\\). We would need to instead resort to some form of imputation. This equates to making assumptions about the distribution \\(P \\left( x \\right)\\), which we would instead have if we consider an extended discriminative model. These can indeed deal with missing observations, given they model the full joint distribution, explicitly via \\(P \\left( y \\vert x \\right)\\) and \\(P \\left(x \\right)\\).\n\n\n\n\n\nGenerative model being used for prediction, with missing inputs \\(\\bar x_m\\). Note that \\(Xo\\), \\(Xm\\) and \\(Y\\) replace \\(\\hat x_o\\), \\(\\bar x_m\\) and \\(\\hat y\\) due to graphviz limitaitons.\n\n\n\n\nIn the generative case, we instead have the joint distribution \\(P_1 \\left( x, y \\vert \\theta \\right)\\). We can therefore use Bayes theorem to get \\(P \\left( \\hat y \\vert \\hat x_o, \\bar x_m , \\theta \\right)\\), as we would anyhow for prediction, and then use the joint distribution with the necessary marginalisations to get \\(P \\left( \\bar x_m \\vert \\hat x_o, \\theta \\right)\\).\nWe can also consider more general forms of missing data, including missing labels and missing inputs in the training data. In the case of generative models, we can train them both in an unsupervised way, when we have no labels, and a semi-supervised way, when we have a few labels. In the case of discriminative models, Minka points out that the extended model can also be trained in a semi-supervised fashion (2005). We will cover this in a future post."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Passing Thoughts",
    "section": "",
    "text": "Generative vs. discriminative models\n\n\nThinking through the differences between generative and discriminative models.\n\n\n\n\nML\n\n\ntheory\n\n\nfactor graphs\n\n\nPGMs\n\n\n \n\n\n\n\n13-06-2022\n\n\n\n\n\n\n  \n\n\n\n\nHeatmaps done right\n\n\nA note on clustering distance matrices before plotting. Think sns.clustermap using altair.\n\n\n\n\nvisualisation\n\n\nhow-to\n\n\n \n\n\n\n\n19-03-2022\n\n\n\n\n\n\n  \n\n\n\n\nSetting up a blog using quarto\n\n\nNotes on how the site was set up. And how to blog using quarto.\n\n\n\n\nhow-to\n\n\n \n\n\n\n\n06-03-2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site contains assorted notes and posts on ML, in the broadest sense possible, and other random topics. We don’t really have a clear theme or reader in mind, and are not sure it deserves to be called a blog. It might instead turn out to be a good place to organise our thougts and keep some notes, in which case the reader is us in six months time.\nThis site is powered by quarto, github and all the other cool tech they in turn leverage."
  }
]